<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Scale Ruler</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: black;
            color: white;
        }
        #ruler {
            position: absolute;
            left: 10px;
            bottom: 10px;
            top: 10px;
            width: 135px;
            background-color: #888;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 
                        0 0 5px rgba(255,255,255,0.2);
        }
        .tick {
            position: absolute;
            right: 0;
            width: 13.5px;
            height: 2px;
            background-color: rgba(0, 0, 0, 0.7);
        }
        .label {
            position: absolute;
            right: 18px;
            font-size: 11.55px;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }
        #items {
            position: absolute;
            left: 155px;
            bottom: 10px;
            right: 10px;
            top: 10px;
            overflow: hidden;
        }
        .item {
            position: absolute;
            left: 0;
            white-space: nowrap;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
        }
        .item::before {
            content: "←";
            margin-right: 5px;
        }
        .item.staggered {
            left: 20px;
        }
        .item.staggered::before {
            content: "↖";
        }
    </style>
</head>
<body>
    <div id="ruler"></div>
    <div id="items"></div>

    <script>
        const ruler = document.getElementById('ruler');
        const items = document.getElementById('items');
        const maxHeight = 135; // 135mm
        let scale = 1;
        let lastTouchY = 0;

        const itemsList = [
            { name: "Cosmic inflation (length)", size: 1e-32, category: "Astronomy", link: "https://en.wikipedia.org/wiki/Cosmic_inflation" },
            { name: "Hawking radiation (wavelength)", size: 1e-10, category: "Physics", link: "https://en.wikipedia.org/wiki/Hawking_radiation" },
            { name: "Endoplasmic reticulum (length)", size: 0.0001, category: "Biology", link: "https://en.wikipedia.org/wiki/Endoplasmic_reticulum" },
            { name: "Eye lens (diameter)", size: 0.009, category: "Biology", link: "https://en.wikipedia.org/wiki/Lens_(anatomy)" },
            { name: "Knuckle (diameter)", size: 0.02, category: "Biology", link: "https://en.wikipedia.org/wiki/Knuckle" },
            { name: "Ear (length)", size: 0.06, category: "Biology", link: "https://en.wikipedia.org/wiki/Ear" },
            { name: "Finger (length)", size: 0.1, category: "Biology", link: "https://en.wikipedia.org/wiki/Finger" },
            { name: "Human brain (length)", size: 0.15, category: "Biology", link: "https://en.wikipedia.org/wiki/Human_brain" },
            { name: "Forearm (length)", size: 0.25, category: "Biology", link: "https://en.wikipedia.org/wiki/Forearm" },
            { name: "Chest (length)", size: 0.4, category: "Biology", link: "https://en.wikipedia.org/wiki/Thorax" },
            { name: "Human spine (length)", size: 0.7, category: "Biology", link: "https://en.wikipedia.org/wiki/Vertebral_column" },
            { name: "Coyote (length)", size: 1.2, category: "Animals", link: "https://en.wikipedia.org/wiki/Coyote" },
            { name: "Geothermal vent (height)", size: 2.0, category: "Geograhy", link: "https://en.wikipedia.org/wiki/Hydrothermal_vent" },
            { name: "Cyclotron (diameter)", size: 5.0, category: "Physics", link: "https://en.wikipedia.org/wiki/Cyclotron" },
            { name: "Kuiper belt (width)", size: 20.0, category: "Astronomy", link: "https://en.wikipedia.org/wiki/Kuiper_belt" },
            { name: "Ethernet cable (length)", size: 100.0, category: "Vehicles", link: "https://en.wikipedia.org/wiki/Ethernet" },
            { name: "Earthquake fault line (length)", size: 1000.0, category: "Geograhy", link: "https://en.wikipedia.org/wiki/Fault_(geology)" },
            { name: "Coral reef (length)", size: 2300.0, category: "Geograhy", link: "https://en.wikipedia.org/wiki/Coral_reef" },
            { name: "Deep-sea trench (depth)", size: 11000.0, category: "Geograhy", link: "https://en.wikipedia.org/wiki/Oceanic_trench" },
            { name: "Earth (diameter)", size: 12740000.0, category: "Astronomy", link: "https://en.wikipedia.org/wiki/Earth" },
            { name: "Cosmic void (diameter)", size: 1e+24, category: "Astronomy", link: "https://en.wikipedia.org/wiki/Void_(astronomy)" }
        ].sort((a, b) => b.size - a.size);

        function getOptimalIncrement(range) {
            const base = Math.pow(10, Math.floor(Math.log10(range)));
            const options = [0.1 * base, 0.2 * base, 0.5 * base, base];
            return options.find(option => range / option >= 4 && range / option <= 10) || base;
        }

        function formatUnit(value) {
            const units = [
                { unit: 'nm', factor: 1e-9 },
                { unit: 'µm', factor: 1e-6 },
                { unit: 'mm', factor: 1e-3 },
                { unit: 'm', factor: 1 },
                { unit: 'km', factor: 1e3 },
                { unit: 'Mm', factor: 1e6 },
                { unit: 'Gm', factor: 1e9 },
                { unit: 'Tm', factor: 1e12 },
                { unit: 'Pm', factor: 1e15 },
            ];

            for (let i = units.length - 1; i >= 0; i--) {
                if (value >= units[i].factor || i === 0) {
                    return `${Math.round(value / units[i].factor)} ${units[i].unit}`;
                }
            }
        }

        function createRuler() {
            ruler.innerHTML = '';
            const height = maxHeight * scale;
            const increment = getOptimalIncrement(height);

            for (let i = 0; i <= height; i += increment) {
                const tick = document.createElement('div');
                tick.className = 'tick';
                tick.style.bottom = `${i * 100 / height}%`;
                ruler.appendChild(tick);

                const label = document.createElement('div');
                label.className = 'label';
                if (i === 0) {
                    label.textContent = '0';
                    label.style.bottom = '2px'; // Move zero position up slightly
                } else {
                    label.textContent = `${formatUnit(i)} (${i.toExponential(0)}m)`;
                    label.style.bottom = `calc(${i * 100 / height}% - 5px)`; // Align text with the dash
                }
                ruler.appendChild(label);
            }
        }

        function updateItems() {
            items.innerHTML = '';
            const visibleItems = itemsList.filter(item => item.size <= maxHeight * scale && item.size >= 0.01 * maxHeight * scale);
            const itemHeight = 20; // Estimated height of each item in pixels
            const minDistance = 10 / items.clientHeight * 100; // 10 pixels in percentage

            let lastPosition = -Infinity;
            visibleItems.forEach((item, index) => {
                const position = item.size * 100 / (maxHeight * scale);
                
                // Skip this item if it's too close to the previous one and smaller
                if (position - lastPosition < minDistance && index > 0 && item.size < visibleItems[index - 1].size) {
                    return;
                }

                const itemElement = document.createElement('div');
                itemElement.className = 'item';
                itemElement.textContent = `${item.name} (${formatUnit(item.size)})`;
                itemElement.style.bottom = `${position}%`;
                
                // Stagger if necessary
                if (position - lastPosition < minDistance) {
                    itemElement.classList.add('staggered');
                    itemElement.style.bottom = `calc(${position}% - 10px)`;
                }
                
                items.appendChild(itemElement);
                lastPosition = position;
            });
        }

        function handleZoom(delta) {
            const zoomFactor = Math.pow(2, 1/8);
            scale = Math.max(1e-10, Math.min(1e10, scale * Math.pow(zoomFactor, -delta)));
            createRuler();
            updateItems();
        }

        function handleWheel(event) {
            event.preventDefault();
            handleZoom(Math.sign(event.deltaY));
        }

        function handleTouchStart(event) {
            lastTouchY = event.touches[0].clientY;
        }

        function handleTouchMove(event) {
            const touchY = event.touches[0].clientY;
            const delta = lastTouchY - touchY;
            handleZoom(Math.sign(delta));
            lastTouchY = touchY;
        }

        createRuler();
        updateItems();
        window.addEventListener('wheel', handleWheel, { passive: false });
        window.addEventListener('touchstart', handleTouchStart, { passive: false });
        window.addEventListener('touchmove', handleTouchMove, { passive: false });
        window.addEventListener('resize', () => {
            createRuler();
            updateItems();
        });
    </script>
</body>
</html>